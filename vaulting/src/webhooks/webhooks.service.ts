import {
  Injectable,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { BlockchainService } from 'src/blockchain/blockchain.service';
import configuration from 'src/config/configuration';
import { TokenStatus } from 'src/config/enum';
import { DatabaseService } from 'src/database/database.service';
import { createHash } from 'crypto';
import { DeltaService } from 'src/delta/delta.service';
import { DetailedLogger } from 'src/logger/detailed.logger';

@Injectable()
export class WebhooksService {
  private readonly logger = new DetailedLogger('WebhookServer', {
    timestamp: true,
  });

  constructor(
    private databaseService: DatabaseService,
    private blockchainService: BlockchainService,
    private deltaService: DeltaService,
  ) {}

  async handleMintEvent(collection: string, tokenId: number, reason: any) {
    const minted = await this.blockchainService.nftMinted(collection, tokenId);
    this.logger.log(
      `Event safeMint: ${collection}, ${tokenId}, minted: ${minted}`,
    );
    if (minted) {
      // update local database
      await this.databaseService.updateTokenStatus(
        collection,
        tokenId,
        TokenStatus.Minted,
      );

      // foward to delta API & palantir
      await this.deltaService.updateTokenStatus(
        collection,
        tokenId,
        TokenStatus.Minted,
      );
    }
  }

  async handleBurnEvent(collection: string, tokenId: number, reason: any) {
    this.logger.log(`Event burn: ${collection}, params: ${tokenId}`);
    const burned = !(await this.blockchainService.nftMinted(
      collection,
      tokenId,
    ));
    if (burned) {
      await this.databaseService.updateTokenStatus(
        collection,
        tokenId,
        TokenStatus.Burned,
      );

      // foward to delta API & palantir
      await this.deltaService.updateTokenStatus(
        collection,
        tokenId,
        TokenStatus.Burned,
      );
    }
  }

  async handleTransferEvent(collection: string, reason: any) {
    this.logger.log(
      `Event Transfer: ${collection}, params: ${JSON.stringify(
        reason['params'],
      )}`,
    );

    const tokenId = Number(reason['params']['tokenId']);
    await this.databaseService.updateTokenStatus(
      collection,
      tokenId,
      TokenStatus.Locked,
    );
    // foward to delta API & palantir
    await this.deltaService.updateTokenStatus(
      collection,
      tokenId,
      TokenStatus.Locked,
    );
  }

  verifyHash(hash: string, request: any) {
    const env = process.env['runtime'];
    const config = configuration()[env];
    const webhookSharedSecret = config['webhook_shared_secret'];
    const toHash = JSON.stringify({
      secret: webhookSharedSecret,
      request: request,
    });
    this.logger.log(toHash);
    const localHash = createHash('sha256').update(toHash).digest('hex');
    this.logger.log(hash, localHash);
    if (hash === localHash) {
      return true;
    } else {
      return false;
    }
  }

  // check if transaction succeeded (no revert)
  async verifyTransaction(tx_hash: string) {
    const receipt = await this.blockchainService.getTransactionReceipt(tx_hash);
    this.logger.log(
      `tx: ${tx_hash}, status: ${receipt.status}, verified: ${
        receipt.status == 1
      }`,
    );
    return receipt.status == 1;
  }

  async callbackHandler(notification: any) {
    const hash = notification['hash'];
    const request = notification['request'];

    // verify the hash generated by the shared secret
    if (!this.verifyHash(hash, request)) {
      throw new InternalServerErrorException(
        `Hash not match: ${hash}, ${request}`,
      );
    }

    const events = request['body']['events'];
    for (var i = 0; i < events.length; i++) {
      const event = events[i];
      const collection = event['matchedAddresses'][0].toLowerCase();
      const tx_hash = event['transaction']['transactionHash'];

      // sanity check: transaction should succeed
      const verified = await this.verifyTransaction(tx_hash);
      if (!verified) {
        this.logger.log(`Ignore transaction: ${tx_hash}`);
        return 'tx ignored';
      }

      for (var j = 0; j < event['matchReasons'].length; j++) {
        const reason = event['matchReasons'][j];
        this.logger.log(`Event received: ${JSON.stringify(reason)}`);
        if (reason['signature'].includes('Transfer')) {
          await this.handleTransferEvent(collection, reason);
        } else if (reason['signature'].includes('safeMint')) {
          const tokenId = Number(reason['params']['tokenId_']);
          await this.handleMintEvent(collection, tokenId, reason);
        } else if (reason['signature'].includes('burn')) {
          const tokenId = Number(reason['params']['tokenId_']);
          await this.handleBurnEvent(collection, tokenId, reason);
        }
      }
    }

    return 'processed';
  }
}
